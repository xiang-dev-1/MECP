/**
 * Expo config plugin: Meshtastic AIDL integration
 *
 * Injects:
 * 1. AIDL interface files into android/app/src/main/aidl/
 * 2. Kotlin native module source into android/app/src/main/java/
 * 3. JitPack repository + meshtastic-android dependencies into build.gradle
 * 4. ReactPackage registration
 *
 * Survives `expo prebuild --clean`.
 */
const {
  withProjectBuildGradle,
  withAppBuildGradle,
  withDangerousMod,
  withMainApplication,
} = require('expo/config-plugins');
const fs = require('fs');
const path = require('path');

// ──── AIDL interface (Meshtastic IMeshService) ────
const AIDL_DIR = 'com/geeksville/mesh';
const AIDL_CONTENT = `// IMeshService.aidl — Meshtastic service interface
// Auto-generated by withMeshtasticAidl Expo config plugin
package com.geeksville.mesh;

interface IMeshService {
  // Get the current node number
  int getMyNodeNum();

  // Send a text message to the mesh
  // Returns the packet ID
  int sendData(in byte[] data, int destNum, int portNum, int channel, int wantAck);

  // Get the list of nodes as a JSON string
  String getNodes();

  // Subscribe to receive messages
  void subscribeReceiver(String packageName, String receiverName);
}
`;

// ──── Kotlin native module ────
const KOTLIN_PACKAGE = 'com/mecp/app/meshtastic';
const KOTLIN_MODULE = `package com.mecp.app.meshtastic

import android.content.BroadcastReceiver
import android.content.ComponentName
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.ServiceConnection
import android.os.IBinder
import android.os.RemoteException
import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.geeksville.mesh.IMeshService
import org.json.JSONArray
import org.json.JSONObject

class MeshtasticAidlModule(private val reactContext: ReactApplicationContext) :
    ReactContextBaseJavaModule(reactContext) {

    private var meshService: IMeshService? = null
    private var isBound = false

    override fun getName() = "MeshtasticAidl"

    private val serviceConnection = object : ServiceConnection {
        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
            meshService = IMeshService.Stub.asInterface(service)
            isBound = true
            sendEvent("MeshtasticConnectionStatus", Arguments.createMap().apply {
                putBoolean("connected", true)
            })
        }

        override fun onServiceDisconnected(name: ComponentName?) {
            meshService = null
            isBound = false
            sendEvent("MeshtasticConnectionStatus", Arguments.createMap().apply {
                putBoolean("connected", false)
            })
        }
    }

    private val messageReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            intent ?: return
            val action = intent.action ?: return

            when (action) {
                "com.geeksville.mesh.RECEIVED.TEXT_MESSAGE_APP" -> {
                    val text = intent.getStringExtra("text") ?: return
                    val fromId = intent.getStringExtra("fromId") ?: "unknown"
                    val channel = intent.getStringExtra("channel")
                    val timestamp = intent.getLongExtra("timestamp", System.currentTimeMillis())
                    val rssi = intent.getIntExtra("rssi", 0)
                    val snr = intent.getFloatExtra("snr", 0f)

                    val params = Arguments.createMap().apply {
                        putString("text", text)
                        putString("fromNodeId", fromId)
                        putString("channel", channel)
                        putDouble("timestamp", timestamp.toDouble())
                        putInt("rssi", rssi)
                        putDouble("snr", snr.toDouble())
                    }
                    sendEvent("MeshtasticMessage", params)
                }
                "com.geeksville.mesh.NODE_CHANGE" -> {
                    val nodeId = intent.getStringExtra("nodeId") ?: return
                    val longName = intent.getStringExtra("longName")
                    val shortName = intent.getStringExtra("shortName")

                    val params = Arguments.createMap().apply {
                        putString("nodeId", nodeId)
                        putString("longName", longName)
                        putString("shortName", shortName)
                    }
                    sendEvent("MeshtasticNodeUpdate", params)
                }
            }
        }
    }

    @ReactMethod
    fun bindService(promise: Promise) {
        try {
            val intent = Intent().apply {
                setClassName(
                    "com.geeksville.mesh",
                    "com.geeksville.mesh.service.MeshService"
                )
            }

            val context = reactContext.applicationContext
            val bound = context.bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)

            if (!bound) {
                promise.reject("BIND_FAILED", "Could not bind to Meshtastic service. Is the Meshtastic app installed?")
                return
            }

            // Register broadcast receivers for incoming messages
            val filter = IntentFilter().apply {
                addAction("com.geeksville.mesh.RECEIVED.TEXT_MESSAGE_APP")
                addAction("com.geeksville.mesh.NODE_CHANGE")
            }
            context.registerReceiver(messageReceiver, filter, Context.RECEIVER_EXPORTED)

            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("BIND_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun unbindService(promise: Promise) {
        try {
            if (isBound) {
                reactContext.applicationContext.unbindService(serviceConnection)
                isBound = false
            }
            try {
                reactContext.applicationContext.unregisterReceiver(messageReceiver)
            } catch (_: Exception) {}
            meshService = null
            promise.resolve(true)
        } catch (e: Exception) {
            promise.reject("UNBIND_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun sendText(text: String, channel: Int, promise: Promise) {
        try {
            val service = meshService
            if (service == null) {
                promise.reject("NOT_CONNECTED", "Not connected to Meshtastic service")
                return
            }

            // portNum 1 = TEXT_MESSAGE_APP
            // destNum 0xFFFFFFFF.toInt() = broadcast
            val data = text.toByteArray(Charsets.UTF_8)
            val packetId = service.sendData(data, 0xFFFFFFFF.toInt(), 1, channel, 1)
            promise.resolve(packetId)
        } catch (e: RemoteException) {
            promise.reject("SEND_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun getNodes(promise: Promise) {
        try {
            val service = meshService
            if (service == null) {
                promise.resolve(Arguments.createArray())
                return
            }

            val nodesJson = service.getNodes()
            val nodesArray = JSONArray(nodesJson)
            val result = Arguments.createArray()

            for (i in 0 until nodesArray.length()) {
                val node = nodesArray.getJSONObject(i)
                val map = Arguments.createMap().apply {
                    putString("nodeId", node.optString("nodeId", ""))
                    putString("longName", node.optString("longName", ""))
                    putString("shortName", node.optString("shortName", ""))
                }
                result.pushMap(map)
            }

            promise.resolve(result)
        } catch (e: Exception) {
            promise.reject("NODES_ERROR", e.message, e)
        }
    }

    @ReactMethod
    fun addListener(eventName: String) {
        // Required for RN NativeEventEmitter
    }

    @ReactMethod
    fun removeListeners(count: Int) {
        // Required for RN NativeEventEmitter
    }

    private fun sendEvent(eventName: String, params: WritableMap) {
        reactContext
            .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter::class.java)
            .emit(eventName, params)
    }
}
`;

const KOTLIN_PACKAGE_FILE = `package com.mecp.app.meshtastic

import com.facebook.react.ReactPackage
import com.facebook.react.bridge.NativeModule
import com.facebook.react.bridge.ReactApplicationContext
import com.facebook.react.uimanager.ViewManager

class MeshtasticAidlPackage : ReactPackage {
    override fun createNativeModules(reactContext: ReactApplicationContext): List<NativeModule> {
        return listOf(MeshtasticAidlModule(reactContext))
    }

    override fun createViewManagers(reactContext: ReactApplicationContext): List<ViewManager<*, *>> {
        return emptyList()
    }
}
`;

function withMeshtasticAidl(config) {
  // 1. Add JitPack to project-level build.gradle
  config = withProjectBuildGradle(config, (config) => {
    const contents = config.modResults.contents;
    if (!contents.includes('jitpack.io')) {
      config.modResults.contents = contents.replace(
        /allprojects\s*\{[\s\S]*?repositories\s*\{/,
        (match) => `${match}\n        maven { url 'https://jitpack.io' }`
      );
    }
    return config;
  });

  // 2. Add dangerous mod to write AIDL + Kotlin files
  config = withDangerousMod(config, [
    'android',
    async (config) => {
      const projectRoot = config.modRequest.projectRoot;
      const androidDir = path.join(projectRoot, 'android', 'app', 'src', 'main');

      // Write AIDL file
      const aidlDir = path.join(androidDir, 'aidl', AIDL_DIR);
      fs.mkdirSync(aidlDir, { recursive: true });
      fs.writeFileSync(
        path.join(aidlDir, 'IMeshService.aidl'),
        AIDL_CONTENT,
        'utf-8'
      );

      // Write Kotlin native module
      const kotlinDir = path.join(androidDir, 'java', KOTLIN_PACKAGE);
      fs.mkdirSync(kotlinDir, { recursive: true });
      fs.writeFileSync(
        path.join(kotlinDir, 'MeshtasticAidlModule.kt'),
        KOTLIN_MODULE,
        'utf-8'
      );
      fs.writeFileSync(
        path.join(kotlinDir, 'MeshtasticAidlPackage.kt'),
        KOTLIN_PACKAGE_FILE,
        'utf-8'
      );

      return config;
    },
  ]);

  // 3. Register the package in MainApplication
  config = withMainApplication(config, (config) => {
    const contents = config.modResults.contents;
    const importLine = 'import com.mecp.app.meshtastic.MeshtasticAidlPackage';
    const packageLine = 'packages.add(MeshtasticAidlPackage())';

    if (!contents.includes('MeshtasticAidlPackage')) {
      // Add import
      config.modResults.contents = contents.replace(
        /import com\.facebook\.react/,
        `${importLine}\nimport com.facebook.react`
      );

      // Add package registration
      config.modResults.contents = config.modResults.contents.replace(
        /override fun getPackages\(\): List<ReactPackage> \{/,
        (match) =>
          `${match}\n            val packages = super.getPackages().toMutableList()\n            ${packageLine}\n            return packages`
      );
    }

    return config;
  });

  return config;
}

module.exports = withMeshtasticAidl;
